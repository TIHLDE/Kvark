// This file is auto-generated by @hey-api/openapi-ts

import { infiniteQueryOptions, queryOptions, type DefaultError, type InfiniteData, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import {
  addGroupMember,
  createApiKey,
  createEvent,
  createEventForm,
  createEventPayment,
  createEventRegistration,
  createFine,
  createForm,
  createFormSubmission,
  createGroup,
  createGroupForm,
  createJob,
  createNews,
  createNewsReaction,
  deleteApiKey,
  deleteEvent,
  deleteEventRegistration,
  deleteFine,
  deleteForm,
  deleteFormSubmission,
  deleteGroup,
  deleteJob,
  deleteNews,
  deleteNewsReaction,
  deleteNotification,
  downloadFormSubmissions,
  getApiKey,
  getEventForm,
  getFavoriteEvents,
  getFine,
  getForm,
  getFormStatistics,
  getFormSubmission,
  getGroup,
  getJob,
  getNews,
  getUserSettings,
  handlePaymentWebhook,
  listAllergies,
  listApiKeys,
  listEventForms,
  listEventRegistrations,
  listEvents,
  listFines,
  listForms,
  listFormSubmissions,
  listGroupForms,
  listGroupMembers,
  listGroups,
  listJobs,
  listNews,
  listNotifications,
  markNotificationRead,
  onboardUser,
  regenerateApiKey,
  removeGroupMember,
  sendCustomEmail,
  updateApiKey,
  updateEvent,
  updateEventFavorite,
  updateFine,
  updateForm,
  updateGroup,
  updateGroupMemberRole,
  updateJob,
  updateNews,
  updateUserSettings,
  validateApiKey,
  type Options,
} from '../sdk.gen';
import type {
  AddGroupMemberData,
  CreateApiKeyData,
  CreateApiKeyResponse,
  CreateEventData,
  CreateEventFormData,
  CreateEventPaymentData,
  CreateEventPaymentResponse,
  CreateEventRegistrationData,
  CreateEventRegistrationResponse,
  CreateEventResponse,
  CreateFineData,
  CreateFormData,
  CreateFormResponse,
  CreateFormSubmissionData,
  CreateGroupData,
  CreateGroupFormData,
  CreateJobData,
  CreateNewsData,
  CreateNewsReactionData,
  DeleteApiKeyData,
  DeleteApiKeyResponse,
  DeleteEventData,
  DeleteEventRegistrationData,
  DeleteEventRegistrationResponse,
  DeleteFineData,
  DeleteFineResponse,
  DeleteFormData,
  DeleteFormSubmissionData,
  DeleteGroupData,
  DeleteGroupResponse,
  DeleteJobData,
  DeleteNewsData,
  DeleteNewsReactionData,
  DeleteNotificationData,
  DeleteNotificationResponse,
  DownloadFormSubmissionsData,
  GetApiKeyData,
  GetApiKeyResponse,
  GetEventFormData,
  GetEventFormResponse,
  GetFavoriteEventsData,
  GetFavoriteEventsResponse,
  GetFineData,
  GetFineResponse,
  GetFormData,
  GetFormResponse,
  GetFormStatisticsData,
  GetFormStatisticsResponse,
  GetFormSubmissionData,
  GetFormSubmissionResponse,
  GetGroupData,
  GetGroupResponse,
  GetJobData,
  GetNewsData,
  GetUserSettingsData,
  GetUserSettingsResponse,
  HandlePaymentWebhookData,
  ListAllergiesData,
  ListAllergiesResponse,
  ListApiKeysData,
  ListApiKeysResponse,
  ListEventFormsData,
  ListEventFormsResponse,
  ListEventRegistrationsData,
  ListEventRegistrationsResponse,
  ListEventsData,
  ListEventsResponse,
  ListFinesData,
  ListFinesResponse,
  ListFormsData,
  ListFormsResponse,
  ListFormSubmissionsData,
  ListFormSubmissionsResponse,
  ListGroupFormsData,
  ListGroupFormsResponse,
  ListGroupMembersData,
  ListGroupMembersResponse,
  ListGroupsData,
  ListGroupsResponse,
  ListJobsData,
  ListNewsData,
  ListNotificationsData,
  ListNotificationsResponse,
  MarkNotificationReadData,
  MarkNotificationReadResponse,
  OnboardUserData,
  OnboardUserResponse,
  RegenerateApiKeyData,
  RegenerateApiKeyResponse,
  RemoveGroupMemberData,
  RemoveGroupMemberResponse,
  SendCustomEmailData,
  SendCustomEmailResponse,
  UpdateApiKeyData,
  UpdateApiKeyResponse,
  UpdateEventData,
  UpdateEventFavoriteData,
  UpdateFineData,
  UpdateFormData,
  UpdateGroupData,
  UpdateGroupMemberRoleData,
  UpdateJobData,
  UpdateNewsData,
  UpdateUserSettingsData,
  UpdateUserSettingsResponse,
  ValidateApiKeyData,
  ValidateApiKeyResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

/**
 * List API keys
 *
 * Get a list of all API keys. Does not include the full key values. Requires 'api-keys:view' permission.
 */
export const listApiKeysOptions = (options?: Options<ListApiKeysData>) =>
  queryOptions<ListApiKeysResponse, DefaultError, ListApiKeysResponse, ReturnType<typeof listApiKeysQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listApiKeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listApiKeysQueryKey(options),
  });

/**
 * Create API key
 *
 * Create a new API key. The full key is returned only once and cannot be retrieved again. Requires 'api-keys:create' permission.
 */
export const createApiKeyMutation = (
  options?: Partial<Options<CreateApiKeyData>>,
): UseMutationOptions<CreateApiKeyResponse, DefaultError, Options<CreateApiKeyData>> => {
  const mutationOptions: UseMutationOptions<CreateApiKeyResponse, DefaultError, Options<CreateApiKeyData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete API key
 *
 * Delete an API key. This action is irreversible. Requires 'api-keys:delete' permission.
 */
export const deleteApiKeyMutation = (
  options?: Partial<Options<DeleteApiKeyData>>,
): UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> => {
  const mutationOptions: UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

/**
 * Get API key
 *
 * Get a single API key by ID. Does not include the full key value. Requires 'api-keys:view' permission.
 */
export const getApiKeyOptions = (options: Options<GetApiKeyData>) =>
  queryOptions<GetApiKeyResponse, DefaultError, GetApiKeyResponse, ReturnType<typeof getApiKeyQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getApiKey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getApiKeyQueryKey(options),
  });

/**
 * Update API key
 *
 * Update an API key's metadata (name, description, permissions, metadata). Cannot update the key itself - use regenerate for that. Requires 'api-keys:update' permission.
 */
export const updateApiKeyMutation = (
  options?: Partial<Options<UpdateApiKeyData>>,
): UseMutationOptions<UpdateApiKeyResponse, DefaultError, Options<UpdateApiKeyData>> => {
  const mutationOptions: UseMutationOptions<UpdateApiKeyResponse, DefaultError, Options<UpdateApiKeyData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Regenerate API key
 *
 * Generate a new key value for an existing API key. The old key will be invalidated. The new full key is returned only once and cannot be retrieved again. Requires 'api-keys:update' permission.
 */
export const regenerateApiKeyMutation = (
  options?: Partial<Options<RegenerateApiKeyData>>,
): UseMutationOptions<RegenerateApiKeyResponse, DefaultError, Options<RegenerateApiKeyData>> => {
  const mutationOptions: UseMutationOptions<RegenerateApiKeyResponse, DefaultError, Options<RegenerateApiKeyData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await regenerateApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Validate API key
 *
 * Check if an API key is valid and return its details. This is a public endpoint that does not require authentication. Updates the lastUsedAt timestamp if the key is valid.
 */
export const validateApiKeyMutation = (
  options?: Partial<Options<ValidateApiKeyData>>,
): UseMutationOptions<ValidateApiKeyResponse, DefaultError, Options<ValidateApiKeyData>> => {
  const mutationOptions: UseMutationOptions<ValidateApiKeyResponse, DefaultError, Options<ValidateApiKeyData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await validateApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Send custom email
 *
 * Send a custom email with structured content blocks. Requires API key authentication via Bearer token.
 */
export const sendCustomEmailMutation = (
  options?: Partial<Options<SendCustomEmailData>>,
): UseMutationOptions<SendCustomEmailResponse, DefaultError, Options<SendCustomEmailData>> => {
  const mutationOptions: UseMutationOptions<SendCustomEmailResponse, DefaultError, Options<SendCustomEmailData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await sendCustomEmail({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventsQueryKey = (options?: Options<ListEventsData>) => createQueryKey('listEvents', options);

/**
 * List events
 */
export const listEventsOptions = (options?: Options<ListEventsData>) =>
  queryOptions<ListEventsResponse, DefaultError, ListEventsResponse, ReturnType<typeof listEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventsQueryKey(options),
  });

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listEventsInfiniteQueryKey = (options?: Options<ListEventsData>): QueryKey<Options<ListEventsData>> => createQueryKey('listEvents', options, true);

/**
 * List events
 */
export const listEventsInfiniteOptions = (options?: Options<ListEventsData>) => {
  return infiniteQueryOptions<
    ListEventsResponse,
    DefaultError,
    InfiniteData<ListEventsResponse>,
    QueryKey<Options<ListEventsData>>,
    number | Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listEventsInfiniteQueryKey(options),
    },
  );
};

/**
 * Create event
 *
 * Create a new event. Requires 'events:create' permission.
 */
export const createEventMutation = (
  options?: Partial<Options<CreateEventData>>,
): UseMutationOptions<CreateEventResponse, DefaultError, Options<CreateEventData>> => {
  const mutationOptions: UseMutationOptions<CreateEventResponse, DefaultError, Options<CreateEventData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createEvent({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update event
 *
 * Update an event by its ID. Event creators can update their own events. Users with 'events:update' or 'events:manage' permission can update any event.
 */
export const updateEventMutation = (options?: Partial<Options<UpdateEventData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateEventData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateEventData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateEvent({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete an event
 *
 * Delete an event by its ID. Event creators can delete their own events. Users with 'events:delete' permission can delete any event. This action is irreversible and will remove all associated data, including registrations and feedback.
 */
export const deleteEventMutation = (options?: Partial<Options<DeleteEventData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteEventData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteEventData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteEvent({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update event favorite
 */
export const updateEventFavoriteMutation = (
  options?: Partial<Options<UpdateEventFavoriteData>>,
): UseMutationOptions<unknown, DefaultError, Options<UpdateEventFavoriteData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateEventFavoriteData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateEventFavorite({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFavoriteEventsQueryKey = (options?: Options<GetFavoriteEventsData>) => createQueryKey('getFavoriteEvents', options);

/**
 * Get all my favorite events
 *
 * Retrieve a list of all events you have marked as favorite.
 */
export const getFavoriteEventsOptions = (options?: Options<GetFavoriteEventsData>) =>
  queryOptions<GetFavoriteEventsResponse, DefaultError, GetFavoriteEventsResponse, ReturnType<typeof getFavoriteEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFavoriteEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFavoriteEventsQueryKey(options),
  });

/**
 * Unregister from event
 */
export const deleteEventRegistrationMutation = (
  options?: Partial<Options<DeleteEventRegistrationData>>,
): UseMutationOptions<DeleteEventRegistrationResponse, DefaultError, Options<DeleteEventRegistrationData>> => {
  const mutationOptions: UseMutationOptions<DeleteEventRegistrationResponse, DefaultError, Options<DeleteEventRegistrationData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteEventRegistration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventRegistrationsQueryKey = (options: Options<ListEventRegistrationsData>) => createQueryKey('listEventRegistrations', options);

/**
 * Get event registrations
 */
export const listEventRegistrationsOptions = (options: Options<ListEventRegistrationsData>) =>
  queryOptions<ListEventRegistrationsResponse, DefaultError, ListEventRegistrationsResponse, ReturnType<typeof listEventRegistrationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEventRegistrations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventRegistrationsQueryKey(options),
  });

export const listEventRegistrationsInfiniteQueryKey = (options: Options<ListEventRegistrationsData>): QueryKey<Options<ListEventRegistrationsData>> =>
  createQueryKey('listEventRegistrations', options, true);

/**
 * Get event registrations
 */
export const listEventRegistrationsInfiniteOptions = (options: Options<ListEventRegistrationsData>) => {
  return infiniteQueryOptions<
    ListEventRegistrationsResponse,
    DefaultError,
    InfiniteData<ListEventRegistrationsResponse>,
    QueryKey<Options<ListEventRegistrationsData>>,
    number | Pick<QueryKey<Options<ListEventRegistrationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListEventRegistrationsData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listEventRegistrations({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listEventRegistrationsInfiniteQueryKey(options),
    },
  );
};

/**
 * Register to an event
 */
export const createEventRegistrationMutation = (
  options?: Partial<Options<CreateEventRegistrationData>>,
): UseMutationOptions<CreateEventRegistrationResponse, DefaultError, Options<CreateEventRegistrationData>> => {
  const mutationOptions: UseMutationOptions<CreateEventRegistrationResponse, DefaultError, Options<CreateEventRegistrationData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createEventRegistration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create payment for event
 *
 * Initiates a Vipps payment for an event registration. User must have a registered status for the event.
 */
export const createEventPaymentMutation = (
  options?: Partial<Options<CreateEventPaymentData>>,
): UseMutationOptions<CreateEventPaymentResponse, DefaultError, Options<CreateEventPaymentData>> => {
  const mutationOptions: UseMutationOptions<CreateEventPaymentResponse, DefaultError, Options<CreateEventPaymentData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createEventPayment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Vipps payment webhook
 *
 * Webhook endpoint for Vipps to notify about payment status changes. Updates payment record based on Vipps payment state.
 */
export const handlePaymentWebhookMutation = (
  options?: Partial<Options<HandlePaymentWebhookData>>,
): UseMutationOptions<unknown, DefaultError, Options<HandlePaymentWebhookData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<HandlePaymentWebhookData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await handlePaymentWebhook({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventFormsQueryKey = (options: Options<ListEventFormsData>) => createQueryKey('listEventForms', options);

/**
 * List event forms
 *
 * Get all forms (survey and evaluation) for an event
 */
export const listEventFormsOptions = (options: Options<ListEventFormsData>) =>
  queryOptions<ListEventFormsResponse, DefaultError, ListEventFormsResponse, ReturnType<typeof listEventFormsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEventForms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventFormsQueryKey(options),
  });

/**
 * Create event form
 *
 * Create a survey or evaluation form for an event. Requires event write permission.
 */
export const createEventFormMutation = (
  options?: Partial<Options<CreateEventFormData>>,
): UseMutationOptions<unknown, DefaultError, Options<CreateEventFormData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateEventFormData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createEventForm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEventFormQueryKey = (options: Options<GetEventFormData>) => createQueryKey('getEventForm', options);

/**
 * Get event form
 *
 * Get a specific form (survey or evaluation) for an event with all fields and options
 */
export const getEventFormOptions = (options: Options<GetEventFormData>) =>
  queryOptions<GetEventFormResponse, DefaultError, GetEventFormResponse, ReturnType<typeof getEventFormQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventForm({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventFormQueryKey(options),
  });

export const listFormsQueryKey = (options?: Options<ListFormsData>) => createQueryKey('listForms', options);

/**
 * List forms
 *
 * List all form templates by default. Use ?all=true to include all forms. Returns template forms by default.
 */
export const listFormsOptions = (options?: Options<ListFormsData>) =>
  queryOptions<ListFormsResponse, DefaultError, ListFormsResponse, ReturnType<typeof listFormsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listForms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFormsQueryKey(options),
  });

/**
 * Create form
 *
 * Create a new base form template. Requires 'forms:create' permission.
 */
export const createFormMutation = (
  options?: Partial<Options<CreateFormData>>,
): UseMutationOptions<CreateFormResponse, DefaultError, Options<CreateFormData>> => {
  const mutationOptions: UseMutationOptions<CreateFormResponse, DefaultError, Options<CreateFormData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createForm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete form
 *
 * Delete a form and all associated data. Requires permission to manage the form.
 */
export const deleteFormMutation = (options?: Partial<Options<DeleteFormData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteFormData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteFormData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteForm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFormQueryKey = (options: Options<GetFormData>) => createQueryKey('getForm', options);

/**
 * Get form
 *
 * Get a form by ID with all fields and options
 */
export const getFormOptions = (options: Options<GetFormData>) =>
  queryOptions<GetFormResponse, DefaultError, GetFormResponse, ReturnType<typeof getFormQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getForm({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFormQueryKey(options),
  });

/**
 * Update form
 *
 * Update a form. Requires permission to manage the form.
 */
export const updateFormMutation = (options?: Partial<Options<UpdateFormData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateFormData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateFormData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateForm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFormStatisticsQueryKey = (options: Options<GetFormStatisticsData>) => createQueryKey('getFormStatistics', options);

/**
 * Get form statistics
 *
 * Get aggregated statistics for a form. Requires permission to manage the form.
 */
export const getFormStatisticsOptions = (options: Options<GetFormStatisticsData>) =>
  queryOptions<GetFormStatisticsResponse, DefaultError, GetFormStatisticsResponse, ReturnType<typeof getFormStatisticsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFormStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFormStatisticsQueryKey(options),
  });

export const listFormSubmissionsQueryKey = (options: Options<ListFormSubmissionsData>) => createQueryKey('listFormSubmissions', options);

/**
 * List submissions
 *
 * List all submissions for a form. Requires permission to manage the form.
 */
export const listFormSubmissionsOptions = (options: Options<ListFormSubmissionsData>) =>
  queryOptions<ListFormSubmissionsResponse, DefaultError, ListFormSubmissionsResponse, ReturnType<typeof listFormSubmissionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFormSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFormSubmissionsQueryKey(options),
  });

/**
 * Create submission
 *
 * Submit answers to a form
 */
export const createFormSubmissionMutation = (
  options?: Partial<Options<CreateFormSubmissionData>>,
): UseMutationOptions<unknown, DefaultError, Options<CreateFormSubmissionData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateFormSubmissionData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createFormSubmission({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFormSubmissionQueryKey = (options: Options<GetFormSubmissionData>) => createQueryKey('getFormSubmission', options);

/**
 * Get submission
 *
 * Get a specific submission. Can view own submission or requires permission to manage the form.
 */
export const getFormSubmissionOptions = (options: Options<GetFormSubmissionData>) =>
  queryOptions<GetFormSubmissionResponse, DefaultError, GetFormSubmissionResponse, ReturnType<typeof getFormSubmissionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFormSubmission({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFormSubmissionQueryKey(options),
  });

export const downloadFormSubmissionsQueryKey = (options: Options<DownloadFormSubmissionsData>) => createQueryKey('downloadFormSubmissions', options);

/**
 * Download submissions as CSV
 *
 * Download all submissions for a form as CSV. Requires permission to manage the form.
 */
export const downloadFormSubmissionsOptions = (options: Options<DownloadFormSubmissionsData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof downloadFormSubmissionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadFormSubmissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadFormSubmissionsQueryKey(options),
  });

/**
 * Delete submission with reason
 *
 * Delete a submission and notify the user with a reason. Admin only.
 */
export const deleteFormSubmissionMutation = (
  options?: Partial<Options<DeleteFormSubmissionData>>,
): UseMutationOptions<unknown, DefaultError, Options<DeleteFormSubmissionData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteFormSubmissionData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteFormSubmission({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listNotificationsQueryKey = (options?: Options<ListNotificationsData>) => createQueryKey('listNotifications', options);

/**
 * List notifications for authenticated user
 *
 * Returns paginated list of notifications for the authenticated user, ordered by most recent first
 */
export const listNotificationsOptions = (options?: Options<ListNotificationsData>) =>
  queryOptions<ListNotificationsResponse, DefaultError, ListNotificationsResponse, ReturnType<typeof listNotificationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listNotifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listNotificationsQueryKey(options),
  });

export const listNotificationsInfiniteQueryKey = (options?: Options<ListNotificationsData>): QueryKey<Options<ListNotificationsData>> =>
  createQueryKey('listNotifications', options, true);

/**
 * List notifications for authenticated user
 *
 * Returns paginated list of notifications for the authenticated user, ordered by most recent first
 */
export const listNotificationsInfiniteOptions = (options?: Options<ListNotificationsData>) => {
  return infiniteQueryOptions<
    ListNotificationsResponse,
    DefaultError,
    InfiniteData<ListNotificationsResponse>,
    QueryKey<Options<ListNotificationsData>>,
    number | Pick<QueryKey<Options<ListNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listNotifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listNotificationsInfiniteQueryKey(options),
    },
  );
};

/**
 * Delete notification
 *
 * Delete a notification by ID. User must be authenticated and own the notification.
 */
export const deleteNotificationMutation = (
  options?: Partial<Options<DeleteNotificationData>>,
): UseMutationOptions<DeleteNotificationResponse, DefaultError, Options<DeleteNotificationData>> => {
  const mutationOptions: UseMutationOptions<DeleteNotificationResponse, DefaultError, Options<DeleteNotificationData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteNotification({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Mark notification as read or unread
 *
 * Update the read status of a notification. User must be authenticated and own the notification.
 */
export const markNotificationReadMutation = (
  options?: Partial<Options<MarkNotificationReadData>>,
): UseMutationOptions<MarkNotificationReadResponse, DefaultError, Options<MarkNotificationReadData>> => {
  const mutationOptions: UseMutationOptions<MarkNotificationReadResponse, DefaultError, Options<MarkNotificationReadData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await markNotificationRead({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listGroupsQueryKey = (options?: Options<ListGroupsData>) => createQueryKey('listGroups', options);

/**
 * List groups
 *
 * Retrieve a list of all groups. Supports optional filtering by type and search query.
 */
export const listGroupsOptions = (options?: Options<ListGroupsData>) =>
  queryOptions<ListGroupsResponse, DefaultError, ListGroupsResponse, ReturnType<typeof listGroupsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listGroups({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listGroupsQueryKey(options),
  });

/**
 * Create group
 *
 * Create a new group. Requires 'groups:create' permission.
 */
export const createGroupMutation = (options?: Partial<Options<CreateGroupData>>): UseMutationOptions<unknown, DefaultError, Options<CreateGroupData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateGroupData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createGroup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a group
 *
 * Delete a group by its slug. Requires being a group leader OR having 'groups:delete' permission (globally or scoped to this group). This action is irreversible and will remove all associated data, including memberships and fines.
 */
export const deleteGroupMutation = (
  options?: Partial<Options<DeleteGroupData>>,
): UseMutationOptions<DeleteGroupResponse, DefaultError, Options<DeleteGroupData>> => {
  const mutationOptions: UseMutationOptions<DeleteGroupResponse, DefaultError, Options<DeleteGroupData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteGroup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getGroupQueryKey = (options: Options<GetGroupData>) => createQueryKey('getGroup', options);

/**
 * Get group by slug
 *
 * Retrieve detailed information about a specific group by its slug identifier.
 */
export const getGroupOptions = (options: Options<GetGroupData>) =>
  queryOptions<GetGroupResponse, DefaultError, GetGroupResponse, ReturnType<typeof getGroupQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGroupQueryKey(options),
  });

/**
 * Partially update group
 *
 * Partially update an existing group by its slug. Only provided fields will be updated. Requires being a group leader OR having 'groups:update' permission (globally or scoped to this group).
 */
export const updateGroupMutation = (options?: Partial<Options<UpdateGroupData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateGroupData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateGroupData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateGroup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listFinesQueryKey = (options: Options<ListFinesData>) => createQueryKey('listFines', options);

/**
 * List fines for a group
 *
 * Retrieve a list of fines for a group. Users can view their own fines, fines admins can view all fines for their group. Supports filtering by status and user.
 */
export const listFinesOptions = (options: Options<ListFinesData>) =>
  queryOptions<ListFinesResponse, DefaultError, ListFinesResponse, ReturnType<typeof listFinesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFinesQueryKey(options),
  });

/**
 * Create fine
 *
 * Create a new fine for a group member. Requires being a group leader OR having 'fines:create' permission (globally or scoped to this group).
 */
export const createFineMutation = (options?: Partial<Options<CreateFineData>>): UseMutationOptions<unknown, DefaultError, Options<CreateFineData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateFineData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createFine({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a fine
 *
 * Delete a fine by its ID. Requires being the fines admin OR having 'fines:delete' permission (globally or scoped to this group). This action is irreversible.
 */
export const deleteFineMutation = (
  options?: Partial<Options<DeleteFineData>>,
): UseMutationOptions<DeleteFineResponse, DefaultError, Options<DeleteFineData>> => {
  const mutationOptions: UseMutationOptions<DeleteFineResponse, DefaultError, Options<DeleteFineData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteFine({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFineQueryKey = (options: Options<GetFineData>) => createQueryKey('getFine', options);

/**
 * Get fine by ID
 *
 * Retrieve detailed information about a specific fine. Users can view their own fines, fines admins can view all fines for their group.
 */
export const getFineOptions = (options: Options<GetFineData>) =>
  queryOptions<GetFineResponse, DefaultError, GetFineResponse, ReturnType<typeof getFineQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFine({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFineQueryKey(options),
  });

/**
 * Partially update fine
 *
 * Partially update a fine. Only provided fields will be updated. Users can add defense to their own fines. Fines admins can update status and approve/reject fines.
 */
export const updateFineMutation = (options?: Partial<Options<UpdateFineData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateFineData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateFineData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateFine({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listGroupMembersQueryKey = (options: Options<ListGroupMembersData>) => createQueryKey('listGroupMembers', options);

/**
 * List group members
 *
 * Retrieve a list of all members in a group.
 */
export const listGroupMembersOptions = (options: Options<ListGroupMembersData>) =>
  queryOptions<ListGroupMembersResponse, DefaultError, ListGroupMembersResponse, ReturnType<typeof listGroupMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listGroupMembers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listGroupMembersQueryKey(options),
  });

/**
 * Add member to group
 *
 * Add a member to a group. Requires 'groups:manage' permission.
 */
export const addGroupMemberMutation = (
  options?: Partial<Options<AddGroupMemberData>>,
): UseMutationOptions<unknown, DefaultError, Options<AddGroupMemberData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddGroupMemberData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await addGroupMember({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove member from group
 *
 * Remove a member from a group. Requires 'groups:manage' permission.
 */
export const removeGroupMemberMutation = (
  options?: Partial<Options<RemoveGroupMemberData>>,
): UseMutationOptions<RemoveGroupMemberResponse, DefaultError, Options<RemoveGroupMemberData>> => {
  const mutationOptions: UseMutationOptions<RemoveGroupMemberResponse, DefaultError, Options<RemoveGroupMemberData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await removeGroupMember({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update member role
 *
 * Update a member's role in a group. Requires 'groups:manage' permission.
 */
export const updateGroupMemberRoleMutation = (
  options?: Partial<Options<UpdateGroupMemberRoleData>>,
): UseMutationOptions<unknown, DefaultError, Options<UpdateGroupMemberRoleData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateGroupMemberRoleData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateGroupMemberRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listGroupFormsQueryKey = (options: Options<ListGroupFormsData>) => createQueryKey('listGroupForms', options);

/**
 * List group forms
 *
 * Get all forms for a group, filtered by user permissions
 */
export const listGroupFormsOptions = (options: Options<ListGroupFormsData>) =>
  queryOptions<ListGroupFormsResponse, DefaultError, ListGroupFormsResponse, ReturnType<typeof listGroupFormsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listGroupForms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listGroupFormsQueryKey(options),
  });

/**
 * Create group form
 *
 * Create a form for a group. Requires group leader permission or forms:create permission.
 */
export const createGroupFormMutation = (
  options?: Partial<Options<CreateGroupFormData>>,
): UseMutationOptions<unknown, DefaultError, Options<CreateGroupFormData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateGroupFormData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createGroupForm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listNewsQueryKey = (options?: Options<ListNewsData>) => createQueryKey('listNews', options);

/**
 * List news articles
 *
 * Get a paginated list of all news articles. Public endpoint.
 */
export const listNewsOptions = (options?: Options<ListNewsData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof listNewsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listNews({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listNewsQueryKey(options),
  });

/**
 * Create news article
 *
 * Create a new news article. Requires 'news:create' permission.
 */
export const createNewsMutation = (options?: Partial<Options<CreateNewsData>>): UseMutationOptions<unknown, DefaultError, Options<CreateNewsData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateNewsData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createNews({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete news article
 *
 * Delete a news article. Requires 'news:delete' or 'news:manage' permission (global or scoped) or being the creator.
 */
export const deleteNewsMutation = (options?: Partial<Options<DeleteNewsData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteNewsData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteNewsData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteNews({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getNewsQueryKey = (options: Options<GetNewsData>) => createQueryKey('getNews', options);

/**
 * Get news article
 *
 * Get a single news article by ID. Public endpoint.
 */
export const getNewsOptions = (options: Options<GetNewsData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getNewsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNews({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNewsQueryKey(options),
  });

/**
 * Update news article
 *
 * Update a news article. Requires 'news:update' or 'news:manage' permission (global or scoped) or being the creator.
 */
export const updateNewsMutation = (options?: Partial<Options<UpdateNewsData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateNewsData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateNewsData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateNews({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove reaction from news
 *
 * Remove your emoji reaction from a news article.
 */
export const deleteNewsReactionMutation = (
  options?: Partial<Options<DeleteNewsReactionData>>,
): UseMutationOptions<unknown, DefaultError, Options<DeleteNewsReactionData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteNewsReactionData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteNewsReaction({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Add reaction to news
 *
 * Add or update emoji reaction to a news article. Requires authentication.
 */
export const createNewsReactionMutation = (
  options?: Partial<Options<CreateNewsReactionData>>,
): UseMutationOptions<unknown, DefaultError, Options<CreateNewsReactionData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateNewsReactionData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createNewsReaction({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listJobsQueryKey = (options?: Options<ListJobsData>) => createQueryKey('listJobs', options);

/**
 * List job postings
 *
 * Get a list of job postings. Supports search and expired filtering. Public endpoint.
 */
export const listJobsOptions = (options?: Options<ListJobsData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof listJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listJobs({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listJobsQueryKey(options),
  });

/**
 * Create job posting
 *
 * Create a new job posting. Requires 'jobs:create' permission.
 */
export const createJobMutation = (options?: Partial<Options<CreateJobData>>): UseMutationOptions<unknown, DefaultError, Options<CreateJobData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateJobData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await createJob({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete job posting
 *
 * Delete a job posting. Requires 'jobs:delete' or 'jobs:manage' permission (global or scoped) or being the creator.
 */
export const deleteJobMutation = (options?: Partial<Options<DeleteJobData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteJobData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteJobData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteJob({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getJobQueryKey = (options: Options<GetJobData>) => createQueryKey('getJob', options);

/**
 * Get job posting
 *
 * Get a single job posting by ID. Public endpoint.
 */
export const getJobOptions = (options: Options<GetJobData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getJobQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getJob({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getJobQueryKey(options),
  });

/**
 * Update job posting
 *
 * Update a job posting. Requires 'jobs:update' or 'jobs:manage' permission (global or scoped) or being the creator.
 */
export const updateJobMutation = (options?: Partial<Options<UpdateJobData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateJobData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateJobData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateJob({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

/**
 * Get current user settings
 *
 * Retrieve the authenticated user's settings including preferences and allergies.
 */
export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) =>
  queryOptions<GetUserSettingsResponse, DefaultError, GetUserSettingsResponse, ReturnType<typeof getUserSettingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSettingsQueryKey(options),
  });

/**
 * Update user settings
 *
 * Partially update the authenticated user's settings. Only provided fields will be updated. User must have completed onboarding first.
 */
export const updateUserSettingsMutation = (
  options?: Partial<Options<UpdateUserSettingsData>>,
): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
  const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateUserSettings({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Complete user onboarding
 *
 * Create initial user settings and mark the user as onboarded. Can only be called once per user.
 */
export const onboardUserMutation = (
  options?: Partial<Options<OnboardUserData>>,
): UseMutationOptions<OnboardUserResponse, DefaultError, Options<OnboardUserData>> => {
  const mutationOptions: UseMutationOptions<OnboardUserResponse, DefaultError, Options<OnboardUserData>> = {
    mutationFn: async (fnOptions) => {
      const { data } = await onboardUser({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAllergiesQueryKey = (options?: Options<ListAllergiesData>) => createQueryKey('listAllergies', options);

/**
 * List all allergies
 *
 * Retrieve a list of all possible allergies that users can have.
 */
export const listAllergiesOptions = (options?: Options<ListAllergiesData>) =>
  queryOptions<ListAllergiesResponse, DefaultError, ListAllergiesResponse, ReturnType<typeof listAllergiesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAllergies({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAllergiesQueryKey(options),
  });
